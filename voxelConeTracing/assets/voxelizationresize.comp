#version 420 core
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_variable_group_size : enable

uniform float uVoxelResolution;
uniform float uBufferSize;
uniform uint uStep;//the resize step... forst step uses main buffer, second step uses resized buffer

struct Voxel
{
  vec3 N;//normal
  vec3 Cd; //color
};

layout( std430, binding = 0 ) buffer VoxelBuffer
{
    Voxel voxels[];
};
layout( std430, binding = 1 )  buffer VoxelResizedBuffer
{
    Voxel voxelsresized[];
};

layout( local_size_x = WG_SIZE_X, local_size_y = WG_SIZE_Y, local_size_z = WG_SIZE_Z ) in;

////////////
void voxelDownSample(uint i)
{
  uint ha = uint(uVoxelResolution)/((uStep+1)*2);//halfres
  uint fr = uint(uVoxelResolution)/min(uStep*2,1);//divisor for fullres... (1,2,4,8)
  uint sq = fr*fr;//squared
  uint saa = i + ( (i/ha)*(ha+fr) ) + ( uint(mod(i,ha)) ) + ( (i/(ha*ha))*sq );//first sample id
  uint sab = saa + fr;
  uint sac = saa + sq;
  uint sad = sac + fr;

  if(uStep<1)
  {
    Voxel v0 = voxels[saa];
    Voxel v1 = voxels[saa+1];
    Voxel v2 = voxels[sab];
    Voxel v3 = voxels[sab+1];
    Voxel v4 = voxels[sac];
    Voxel v5 = voxels[sac+1];
    Voxel v6 = voxels[sad];
    Voxel v7 = voxels[sad+1];

    vec3 pa = vec3(v0.Cd+v1.Cd+v2.Cd+v3.Cd+v4.Cd+v5.Cd+v6.Cd+v7.Cd)/8.0f;
    vec3 na = vec3(v0.N+v1.N+v2.N+v3.N+v4.N+v5.N+v6.N+v7.N)/8.0f;
  }
  else
  {
    uint ioffr = uint(uVoxelResolution)/(min(uStep,1)*2);//id offset resolution
    uint ioffset = ioffr*ioffr*ioffr;
    //OFFSET NEEDS TO LOOK BACKWARDS?????
    Voxel v0 = voxelsresized[saa+ioffset];
    Voxel v1 = voxelsresized[saa+1+ioffset];
    Voxel v2 = voxelsresized[sab+ioffset];
    Voxel v3 = voxelsresized[sab+1+ioffset];
    Voxel v4 = voxelsresized[sac+ioffset];
    Voxel v5 = voxelsresized[sac+1+ioffset];
    Voxel v6 = voxelsresized[sad+ioffset];
    Voxel v7 = voxelsresized[sad+1+ioffset];

    vec3 pa = vec3(v0.Cd+v1.Cd+v2.Cd+v3.Cd+v4.Cd+v5.Cd+v6.Cd+v7.Cd)/8.0f;
    vec3 na = vec3(v0.N+v1.N+v2.N+v3.N+v4.N+v5.N+v6.N+v7.N)/8.0f;
  }

}
//////////////////////////
//
////////////////////////////////////
/////////////////////////////////////

void main(){
	uint gid = gl_GlobalInvocationID.x;	// The .y and .z are both 1 in this case.
  	if( gid >= uBufferSize )
    	return;

    //uVoxelResolution/2
    voxelsresized[gid].Cd = vec3(1.0f);//v0.Cd;
    //voxels[ind1].Cd = vec3(1.0f);//v1.Cd;

    
}